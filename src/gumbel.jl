## Archimedean Generators
"""
Abstract type for the families of archimedean copulas.

Concrete subtypes need an implementation of `generator`, its `inverse` and `inverse_laplace_trafo`.

Optional methods are `isless`, `upper_taildep` and `lower_taildep`.
"""
abstract type Archimedean end

"""
    generator(a::Archimedean)

Needs to be implemented for each concrete sub-type of `Archimedean`.

"""
generator(a::Archimedean) = error("Generator for $(typeof(a)) to be defined")

"""
Objects can be called to evaluate the archimedean generator.

See also: `generator`.
"""
(a::Archimedean)(t) = generator(a)(t)

"""
    inverse(a)

Return the inverse function of the archimedean generator `a`.
"""
inverse(a::Archimedean) = error("inverse generator for $(typeof(a)) to be implemented")

"""
    inverse_laplace_trafo(a)

Return the inverse Laplace transformation of the archimedean generator `a`.
"""
inverse_laplace_trafo(a::Archimedean) = error("inverse Laplace transformation for $(typeof(a)) to be defined")

"""
    isless(a,b)

The order of archimedean generators of the same family underlying the monotonicity condition 
for nested archimedean copulas.  
"""
Base.isless(::A, ::A) where {A<:Archimedean} = error("isless for $A is not defined")

"""
upper_taildep(a)

Return the upper tail dependence of a copula generated by `a`.
"""
upper_taildep(a::Archimedean) = error("upper_taildep for $(typeof(a)) is not defined")

"""
lower_taildep(a)

Return the lower tail dependence of a copula generated by `a`.
"""
lower_taildep(a::Archimedean) = error("lower_taildep for $(typeof(a)) is not defined")

"""
    mvcdf(a, u)

Evaluate the length(u)-dimensional archimedean copula generated by `a` at `u`.
"""
mvcdf(a::Archimedean, u::Vector{Float64}) = all(u .>= 0) & all(u .<= 1) ?
                                       a(sum(inverse(a)(v) for v in u)) :  # works for any number of marginals
                                       throw(DomainError(u, "all arguments must be between 0 and 1"))

## The Gumbel family

"""
    Gumbel(theta)

Encodes the `Gumbel` generator `t -> exp(-t^(1 / theta))`.

# Example
```jldoctest
julia> g = Gumbel(1.2)
Gumbel(1.2)

julia> g(2.34)
0.13122268534047923

julia> g.([0,Inf])
2-element Vector{Float64}:
 1.0
 0.0
```
See also: `Archimedean`.
"""
struct Gumbel <: Archimedean
    theta::Float64
    Gumbel(theta) = theta < one(theta) ? throw(ArgumentError("Gumbel theta must be >= 1")) :
                    new(theta)
end

Gumbel() = Gumbel(1.0) # default
generator(g::Gumbel) = t -> exp(-t^(1 / g.theta))
inverse(g::Gumbel) = x -> (-log(x))^g.theta
Base.isless(g::Gumbel, h::Gumbel) = g.theta < h.theta # needs to be fulfilled for monotonicty in NestedCopula

upper_taildep(g::Gumbel) = 2 - 2^(1 / g.theta)
lower_taildep(g::Gumbel) = zero(g.theta)

Base. /(g::Gumbel, h::Gumbel) = Gumbel(g.theta / h.theta)

inverse_laplace_trafo(g::Gumbel) =
    g.theta > one(g.theta) ?
    AlphaStable(α=1.0 / g.theta, β=1.0, scale=(cos(π / (2.0 * g.theta)))^g.theta) :
    AlphaStable(α=1.0, β=1.0, scale=0.0, location=1.0)

## Node Parameterisation for nested archimedean copulas
"""
    Copula(a::Archimedean,n::Integer)

Parameterisation of archimedean copula of family `a` and dimension `n`.
"""
struct Copula{A<:Archimedean}
    a::A
    dim::Int
    Copula{A}(a,dim) where A = dim < zero(dim) ? throw(ArgumentError("Dimension must be >=0")) :
        new{A}(a,dim)
end
Copula(a::Archimedean,n::Integer) = Copula{typeof(a)}(a,n) 
generator(c::Copula{<:Archimedean}) = c.a

"""
    family(c)

The archimedean family of `c` is identified by the type of its generator. 
"""
family(::Copula{A}) where {A<:Archimedean} = A

"""
    dimension(c) 

The number of marginals of the copula
"""
dimension(c::Copula{<:Archimedean}) = Int(c.dim)

@forward Copula.a upper_taildep, lower_taildep

# This is Gumbel specific and simplifies the implementation of the sampling algorithm
Base. /(c::Copula{Gumbel}, g::Gumbel) = Copula{Gumbel}(generator(c) / g, dimension(c))

## Nested archimedean copulas

#See  https://cran.r-project.org/web/packages/copula/vignettes/nacopula-pkg.pdf

"""
    Enforces monotonicity requirement when nesting archimedean copulas. 
"""
struct ArchimedeanMonotonicity <: NestingCondition end

"""
    NestedCopula{A}(nv) 
    NestedCopula(nv)

Alias for `NestedData{Copula{A},ArchimedeanMonotonicity}`. Encodes nested archimedean copulas
for the familiy `A` as described in https://cran.r-project.org/web/packages/copula/vignettes/nacopula-pkg.pdf

See also: `nestedcopula`. 
"""
const NestedCopula{A<:Archimedean} = NestedData{Copula{A},ArchimedeanMonotonicity}

is_condition_valid(::ArchimedeanMonotonicity, z::NestedCopula) = 
    is_condition_valid(IsIncreasing(), map(generator, z::NestedCopula))

"""
nestedcopula(c...)

Nest archimedean copulas of the same family. Same syntax as `nest(x...)` for nesting values. 

See also: `nest`, `Copula`.

"""
nestedcopula(c...) = nest(typeof(c[1]),ArchimedeanMonotonicity(),c)

Base. /(c::NestedCopula{Gumbel}, g::Gumbel) = transform(z -> z / g, c)

function dimension(c::NestedCopula{<:Archimedean})
    d = dimension(start(c))
    for h in nestings(c)
        d += dimension(h)
    end
    return d
end

family(::NestedCopula{A}) where {A<:Archimedean} = A

"""
    c(u)

Evaluate the copula.
"""
function (c::NestedCopula)(u::Vector{Float64})
    dimension(c) > 0 ||
        throw(ArgumentError("copula function in dimesion 0 is not defined"))
    length(u) == dimension(c) ||
        throw(DomainError(u, "$(dimension(c)) arguments needed."))
    all(0.0 .<= u) && all(u .<= 1.0) ||
        throw(DomainError(u, "All arguments must be between 0 and 1."))

    d = dimension(start(c))
    v = collect(u) # do not want to modify u in operation below
    q = d == 0 ? similar(v,0) : splice!(v,1:d)
    # same as q, v = v[1:d], v[d+1:end]
    for h in nestings(c)
        d = dimension(h)
        p = d == 0 ? similar(v,0) : splice!(v,1:d)
        # same as p, v = v[1:d], v[d+1:end]
        push!(q, h(p))
    end
    mvcdf(generator(start(c)), q)
end

#  Note that sampling from a nested Gumbel copula is easier than for the other nested archimedeans. 
#  The algorithm below is the origial from A. McNeil where the special case that 
#  the Laplace-Stieltjes transform
#  used in the recursive step is of the same family as for sampling from the Gumbel copula 
#  (compare  Tables 3 and 1 
#  in Hofert https://cran.r-project.org/web/packages/copula/vignettes/nacopula-pkg.pdf )
#  The algorithm below would need to be extended such that the cases of Algorithm 3.2 in 
#  Hofert are covered. 
"""
    sample(c, n)

Draw `n` independent samples from copula `c`.
"""
function sample(c::NestedCopula{Gumbel}, n::Int)
    smp = rand(n, dimension(start(c)))

    for h in nestings(c) # here Gumbel is easier than the other NestedArchimedeans 
        h1 = h / generator(start(c))
        smp = [smp sample(h1, n)]
    end
    generator(start(c)).theta > 1.0 + 1e-10 || return smp # cannot be distinguished from the independent case
    v = rand(inverse_laplace_trafo(generator(start(c))), n)

    return generator(start(c)).(-log.(smp) ./ v)
end