## Archimedean Generators
"""
Abstract type for the families of archimedean copulas.

Concrete subtypes need an implementation of `generator`, its `inverse` and `inverse_laplace_trafo`.

Optional methods are `is_less`, `upper_taildep` and `lower_taildep`.
"""
abstract type Archimedean end

"""
    generator(a::Archimedean)

Needs to be implemented for each concrete sub-type of `Archimedean`.

"""
generator(a::Archimedean) = error("Generator for $(typeof(a)) to be defined")

"""
Objects can be called to evaluate the archimedean generator.

See also: `generator`.
"""
(a::Archimedean)(t) = generator(a)(t)

"""
    inverse(a)

Return the inverse function of the archimedean generator `a`.
"""
inverse(a::Archimedean) = error("inverse generator for $(typeof(a)) to be implemented")

"""
    inverse_laplace_trafo(a)

Return the inverse Laplace transformation of the archimedean generator `a`.
"""
inverse_laplace_trafo(a::Archimedean) = error("inverse Laplace transformation for $(typeof(a)) to be defined")

"""
    isless(a,b)

The order of archimedean generators of the same family underlying the monotonicity condition 
for nested archimedean copulas.  
"""
Base.isless(::A, ::A) where {A<:Archimedean} = error("isless for $A is not defined")

"""
upper_taildep(a)

Return the upper tail dependence of a copula generated by `a`.
"""
upper_taildep(a::Archimedean) = error("upper_taildep for $(typeof(a)) is not defined")

"""
lower_taildep(a)

Return the lower tail dependence of a copula generated by `a`.
"""
lower_taildep(a::Archimedean) = error("lower_taildep for $(typeof(a)) is not defined")

"""
    mvcdf(a, u)

Evaluate the length(u)-dimensional archimedean copula generated by `a` at `u`.
"""
mvcdf(a::Archimedean, u::Vector{Float64}) = all(u .>= 0) & all(u .<= 1) ?
                                       a(sum(inverse(a)(v) for v in u)) :  # works for any number of marginals
                                       throw(DomainError(u, "all arguments must be between 0 and 1"))


## The Gumbel family

"""
    Gumbel(theta)

Encodes the `Gumbel` generator `t -> exp(-t^(1 / theta))`.

# Example
```jldoctest
julia> g = Gumbel(1.2)
Gumbel(1.2)

julia> g(2.34)
0.13122268534047923

julia> g.([0,Inf])
2-element Vector{Float64}:
 1.0
 0.0
```
See also: `Archimedean`.
"""
struct Gumbel <: Archimedean
    theta::Float64
    Gumbel(theta) = theta < one(theta) ? throw(ArgumentError("Gumbel theta must be >= 1")) :
                    new(theta)
end

Gumbel() = Gumbel(1.0) # default
generator(g::Gumbel) = t -> exp(-t^(1 / g.theta))
inverse(g::Gumbel) = x -> (-log(x))^g.theta
Base.isless(g::Gumbel, h::Gumbel) = g.theta < h.theta # needs to be fulfilled for monotonicty in NestedCopula

upper_taildep(g::Gumbel) = 2 - 2^(1 / g.theta)
lower_taildep(g::Gumbel) = zero(g.theta)

Base. /(g::Gumbel, h::Gumbel) = Gumbel(g.theta / h.theta)

inverse_laplace_trafo(g::Gumbel) = g.theta > one(g.theta) ?
                                   AlphaStable(α=1.0 / g.theta, β=1.0, scale=(cos(π / (2.0 * g.theta)))^g.theta) :
                                   AlphaStable(α=1.0, β=1.0, scale=0.0, location=1.0)

## Node Parameterisation for nested archimedean copulas


struct Copula{A<:Archimedean}
    a::A
    dim::UInt
end

generator(c::Copula{<:Archimedean}) = c.a
family(::Copula{A}) where {A<:Archimedean} = A

"""
    dimension(c) 

The number of marginals of the copula
"""
dimension(c::Copula{<:Archimedean}) = Int(c.dim)

@forward Copula.a upper_taildep, lower_taildep

# This is Gumbel specific and simplifies the implementation of the sampling algorithm
Base. /(c::Copula{Gumbel}, g::Gumbel) = Copula{Gumbel}(generator(c) / g, dimension(c))

## Nested archimedean copulas

#See  https://cran.r-project.org/web/packages/copula/vignettes/nacopula-pkg.pdf

"""
    NestedCopula{A}(nv) 
    NestedCopula(nv)

Construct a copula parametrised by `NestedValues` of archimedean copulas from the same family `A`.

See also: `nestedcopula`. 
"""
struct NestedCopula{A<:Archimedean} <: Nesting{Copula{A}}
    nvc::NestedValues{Copula{A}}
    function NestedCopula{A}(nvc) where A
        _check_monotonicity(nvc) ||
            throw(ArgumentError("Monotonicity condition for generators not fulfilled."))
        return new{A}(nvc)
    end
end

function _check_monotonicity(g::NestedValues{Copula{A}}) where {A<:Archimedean}
    for h in nestings(g)
        generator(start(g)) <= generator(start(h)) || return false
        _check_monotonicity(h) || return false
    end
    return true
end

parameters(c::NestedCopula) = c.nvc

NestedCopula(nvc::NestedValues{Copula{A}}) where A = NestedCopula{A}(nvc)

#NestedCopula(c::Copula{A}, vnc::Vector{NestedCopula{A}}) where A = NestedValues

nestedcopula(c...) = NestedCopula(nest(c...))

NestedCopula{Gumbel}(z::NestedValues{Pair{Float64,Int}}) =
    NestedCopula(map(p -> Copula{Gumbel}(Gumbel(first(p)), last(p)), z))
nestedgumbel(g...) = NestedCopula{Gumbel}(nest(Pair{Float64,Int},g))

@forward NestedCopula.nvc start

nestings(c::NestedCopula{A}) where {A<:Archimedean} = NestedCopula{A}.(nestings(c.nvc)) #forward does not work for this
map(f::Function, z::NestedCopula) = map(f, z.nvc)


function dimension(c::NestedCopula{<:Archimedean})
    d = dimension(start(c))
    for h in nestings(c)
        d += dimension(h)
    end
    return d
end

"""
    family(c)

The archimedean family of `c` is identified by the type of its generator. 
"""
family(::NestedCopula{A}) where {A<:Archimedean} = A

Base. /(c::NestedCopula{Gumbel}, g::Gumbel) = NestedCopula{Gumbel}(map(z -> z / g, c))


"""
    c(u)

Evaluate the copula at 
"""
function (c::NestedCopula)(u::Vector{Float64})
    dimension(c) > 0 ||
        throw(ArgumentError("copula function in dimesion 0 is not defined"))
    length(u) == dimension(c) ||
        throw(DomainError(u, "$(dimension(c)) arguments needed, equal to number of copulas marginals."))
    all(0.0 .<= u) && all(u .<= 1.0) ||
        throw(DomainError(u, "all arguments must be between 0 and 1"))

    d = dimension(start(c))
    v = collect(u)
    q = d == 0 ? similar(v,0) : splice!(v,1:d)
    # same as q, v = v[1:d], v[d+1:end]
    for h in nestings(c)
        d = dimension(h)
        p = d == 0 ? similar(v,0) : splice!(v,1:d)
        # same as p, v = v[1:d], v[d+1:end]
        push!(q, h(p))
    end
    mvcdf(generator(start(c)), q)
end

#  Note that sampling from a nested Gubel copula  is easier than for the other nested Archimedean. The algorithm
#  below the origial from McNeil where the special case that the Laplace-Stieltjes transform
#  used in the recursive step is of the same family as for sampling from the Gumbel copula 
#  (compare  Tables 3 and 1 
#  in Hofert https://cran.r-project.org/web/packages/copula/vignettes/nacopula-pkg.pdf )
#  The algorithm below would need to be extended so the cases of Algorithm 3.2 in Hofert are covered. 
"""
    sample(c, nsmp)

Drawing `nsmp` independent samples from copula `c`.
"""
function sample(c::NestedCopula{Gumbel}, nsmp::Int)
    smp = rand(dimension(start(c)), nsmp)

    for h in nestings(c) # here Gumbel is easier than the other NestedArchimedeans 
        h1 = h / generator(start(c))
        smp = [smp; sample(h1, nsmp)]
    end
    generator(start(c)).theta > 1.0 + 1e-10 || return smp # cannot be distinguished from the independent case
    v = rand(inverse_laplace_trafo(generator(start(c))), 1, nsmp)

    return generator(start(c)).(-log.(smp) ./ v)
end